library(roxygen2)
library(httr)
library(jsonlite)
library(tibble)
library(dplyr)
library(tidyverse)
library(lubridate)
library(scales)
library(roxygen2)
get_plot <- function(data){
flat_list <- enframe(data$near_earth_objects, name = "date", value = "asteroids")
neo_data <- flat_list %>%
unnest(cols = c(asteroids)) %>%
mutate(date = as.Date(date))
flattened_close_approach_data <- enframe(neo_data$close_approach_data) %>% unnest(cols = c(value))
flattened_close_approach_data$miss_distance$kilometers <- as.numeric(flattened_close_approach_data$miss_distance$kilometers)
est_diameter_avg <- (neo_data$estimated_diameter$kilometers$estimated_diameter_max + neo_data$estimated_diameter$kilometers$estimated_diameter_min)/2
neo_data <- neo_data %>%
mutate(full_date = flattened_close_approach_data$close_approach_date_full) %>%
mutate(miss_distance_km = flattened_close_approach_data$miss_distance$kilometers) %>%
mutate(approach_velocity_km_per_h = flattened_close_approach_data$relative_velocity$kilometers_per_hour) %>%
mutate(est_diameter_avg = est_diameter_avg)
neo_data$full_date <- parse_date_time(neo_data$full_date, orders = "%Y-%b-%d %H:%M")
neo_data$full_date <- as.POSIXct(neo_data$full_date)
plot <- ggplot(neo_data, aes(x = full_date, y = miss_distance_km, size = est_diameter_avg, color = est_diameter_avg)) +
geom_point() +
ggtitle("Near Earth Objects") +
labs(x = '', y = "Miss Distance from Earth (km)", size = 'Estimated Diameter', color = '') +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_datetime(
labels = date_format("%Y-%m-%d %H:%M"),
breaks = pretty_breaks(n = 5)
) +
scale_y_continuous(
labels = scales::comma_format(scale = 1, accuracy = 1),
breaks = scales::pretty_breaks(n = 7)
) +
scale_color_viridis_c(guide = guide_colorbar(reverse = TRUE))
return(plot)
}
get_response <- function(start_date, end_date){
url <- "https://api.nasa.gov/neo/rest/v1/feed"
# start_date <- '2015-09-07'
# end_date <- '2015-09-12'
api_key <- 'gEQLIrhs9YeVTGJR9cLQ3ywn4hjsJOO59oe70KVC'
modified_url <- modify_url(url, query=list(start_date = start_date, end_date = end_date, api_key = api_key))
response <- GET(modified_url)
if (response$status_code == 200){
return(response)
}else {
print('response$headers$`x-ratelimit-remaining`')
return('Response status code not 200')
}
}
check_date <- function(start_date, end_date) {
tryCatch(
{
parsed_start_date <- as.Date(start_date)
parsed_end_date <- as.Date(end_date)
if (parsed_end_date - parsed_start_date > 7){
print('Difference between start and end date must be 7 days or less.')
return('7_d_fail')
} else {
return('PASS')
}
},
error = function(e) {
print('Date format should be in YYYY-MM-DD format.')
warning("Invalid date format. Please enter a valid date.")
}
)
}
#' Get Near Earth Objects (NEO) Data and Plot
#'
#' This function retrieves Near Earth Objects (NEO) data for a specified date range,
#' checks the validity of the date range, and plots the data if the request is successful.
#'
#' @param start_date A character string specifying the start date in 'YYYY-MM-DD' format.
#' @param end_date A character string specifying the end date in 'YYYY-MM-DD' format.
#'
#' @return A plot of NEO data if the request is successful; otherwise, an error message.
#'
#' @examples
#' get_neo('2023-01-01', '2023-01-07')
#'
#' @export
get_neo <- function(start_date, end_date){
check <- check_date(start_date, end_date)
if (check == '7_d_fail'){
print("Try another start and end date or check date format.")
return('Request failed')
}else {
response <- get_response(start_date, end_date)
}
if (response$status_code == 200){
data <- fromJSON(response$url)
plot <- get_plot(data)
print(plot)
return(plot)
}else {
return("Failed")
}
}
?get_neo
??get_neo
help(get_neo)
library(httr)
library(jsonlite)
library(tibble)
library(dplyr)
library(tidyverse)
library(lubridate)
library(scales)
library(roxygen2)
get_plot <- function(data){
flat_list <- enframe(data$near_earth_objects, name = "date", value = "asteroids")
neo_data <- flat_list %>%
unnest(cols = c(asteroids)) %>%
mutate(date = as.Date(date))
flattened_close_approach_data <- enframe(neo_data$close_approach_data) %>% unnest(cols = c(value))
flattened_close_approach_data$miss_distance$kilometers <- as.numeric(flattened_close_approach_data$miss_distance$kilometers)
est_diameter_avg <- (neo_data$estimated_diameter$kilometers$estimated_diameter_max + neo_data$estimated_diameter$kilometers$estimated_diameter_min)/2
neo_data <- neo_data %>%
mutate(full_date = flattened_close_approach_data$close_approach_date_full) %>%
mutate(miss_distance_km = flattened_close_approach_data$miss_distance$kilometers) %>%
mutate(approach_velocity_km_per_h = flattened_close_approach_data$relative_velocity$kilometers_per_hour) %>%
mutate(est_diameter_avg = est_diameter_avg)
neo_data$full_date <- parse_date_time(neo_data$full_date, orders = "%Y-%b-%d %H:%M")
neo_data$full_date <- as.POSIXct(neo_data$full_date)
plot <- ggplot(neo_data, aes(x = full_date, y = miss_distance_km, size = est_diameter_avg, color = est_diameter_avg)) +
geom_point() +
ggtitle("Near Earth Objects") +
labs(x = '', y = "Miss Distance from Earth (km)", size = 'Estimated Diameter', color = '') +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_datetime(
labels = date_format("%Y-%m-%d %H:%M"),
breaks = pretty_breaks(n = 5)
) +
scale_y_continuous(
labels = scales::comma_format(scale = 1, accuracy = 1),
breaks = scales::pretty_breaks(n = 7)
) +
scale_color_viridis_c(guide = guide_colorbar(reverse = TRUE))
return(plot)
}
get_response <- function(start_date, end_date){
url <- "https://api.nasa.gov/neo/rest/v1/feed"
# start_date <- '2015-09-07'
# end_date <- '2015-09-12'
api_key <- 'gEQLIrhs9YeVTGJR9cLQ3ywn4hjsJOO59oe70KVC'
modified_url <- modify_url(url, query=list(start_date = start_date, end_date = end_date, api_key = api_key))
response <- GET(modified_url)
if (response$status_code == 200){
return(response)
}else {
print('response$headers$`x-ratelimit-remaining`')
return('Response status code not 200')
}
}
check_date <- function(start_date, end_date) {
tryCatch(
{
parsed_start_date <- as.Date(start_date)
parsed_end_date <- as.Date(end_date)
if (parsed_end_date - parsed_start_date > 7){
print('Difference between start and end date must be 7 days or less.')
return('7_d_fail')
} else {
return('PASS')
}
},
error = function(e) {
print('Date format should be in YYYY-MM-DD format.')
warning("Invalid date format. Please enter a valid date.")
}
)
}
#' Get Near Earth Objects (NEO) Data and Plot
#'
#' This function retrieves Near Earth Objects (NEO) data for a specified date range,
#' checks the validity of the date range, and plots the data if the request is successful.
#'
#' @param start_date A character string specifying the start date in 'YYYY-MM-DD' format.
#' @param end_date A character string specifying the end date in 'YYYY-MM-DD' format.
#'
#' @return A plot of NEO data if the request is successful; otherwise, an error message.
#'
#' @examples
#' get_neo('2023-01-01', '2023-01-07')
get_neo <- function(start_date, end_date){
check <- check_date(start_date, end_date)
if (check == '7_d_fail'){
print("Try another start and end date or check date format.")
return('Request failed')
}else {
response <- get_response(start_date, end_date)
}
if (response$status_code == 200){
data <- fromJSON(response$url)
plot <- get_plot(data)
print(plot)
return(plot)
}else {
return("Failed")
}
}
a <- get_neo('2018-01-07','2018-01-10')
??get_neo
??get_neo
library(httr)
library(jsonlite)
library(tibble)
library(dplyr)
library(tidyverse)
library(lubridate)
library(scales)
library(roxygen2)
get_plot <- function(data){
flat_list <- enframe(data$near_earth_objects, name = "date", value = "asteroids")
neo_data <- flat_list %>%
unnest(cols = c(asteroids)) %>%
mutate(date = as.Date(date))
flattened_close_approach_data <- enframe(neo_data$close_approach_data) %>% unnest(cols = c(value))
flattened_close_approach_data$miss_distance$kilometers <- as.numeric(flattened_close_approach_data$miss_distance$kilometers)
est_diameter_avg <- (neo_data$estimated_diameter$kilometers$estimated_diameter_max + neo_data$estimated_diameter$kilometers$estimated_diameter_min)/2
neo_data <- neo_data %>%
mutate(full_date = flattened_close_approach_data$close_approach_date_full) %>%
mutate(miss_distance_km = flattened_close_approach_data$miss_distance$kilometers) %>%
mutate(approach_velocity_km_per_h = flattened_close_approach_data$relative_velocity$kilometers_per_hour) %>%
mutate(est_diameter_avg = est_diameter_avg)
neo_data$full_date <- parse_date_time(neo_data$full_date, orders = "%Y-%b-%d %H:%M")
neo_data$full_date <- as.POSIXct(neo_data$full_date)
plot <- ggplot(neo_data, aes(x = full_date, y = miss_distance_km, size = est_diameter_avg, color = est_diameter_avg)) +
geom_point() +
ggtitle("Near Earth Objects") +
labs(x = '', y = "Miss Distance from Earth (km)", size = 'Estimated Diameter', color = '') +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_datetime(
labels = date_format("%Y-%m-%d %H:%M"),
breaks = pretty_breaks(n = 5)
) +
scale_y_continuous(
labels = scales::comma_format(scale = 1, accuracy = 1),
breaks = scales::pretty_breaks(n = 7)
) +
scale_color_viridis_c(guide = guide_colorbar(reverse = TRUE))
return(plot)
}
get_response <- function(start_date, end_date){
url <- "https://api.nasa.gov/neo/rest/v1/feed"
# start_date <- '2015-09-07'
# end_date <- '2015-09-12'
api_key <- 'gEQLIrhs9YeVTGJR9cLQ3ywn4hjsJOO59oe70KVC'
modified_url <- modify_url(url, query=list(start_date = start_date, end_date = end_date, api_key = api_key))
response <- GET(modified_url)
if (response$status_code == 200){
return(response)
}else {
print('response$headers$`x-ratelimit-remaining`')
return('Response status code not 200')
}
}
check_date <- function(start_date, end_date) {
tryCatch(
{
parsed_start_date <- as.Date(start_date)
parsed_end_date <- as.Date(end_date)
if (parsed_end_date - parsed_start_date > 7){
print('Difference between start and end date must be 7 days or less.')
return('7_d_fail')
} else {
return('PASS')
}
},
error = function(e) {
print('Date format should be in YYYY-MM-DD format.')
warning("Invalid date format. Please enter a valid date.")
}
)
}
get_neo <- function(start_date, end_date){
#' Get Near Earth Objects (NEO) Data and Plot
#'
#' This function retrieves Near Earth Objects (NEO) data for a specified date range,
#' checks the validity of the date range, and plots the data if the request is successful.
#'
#' @param start_date A character string specifying the start date in 'YYYY-MM-DD' format.
#' @param end_date A character string specifying the end date in 'YYYY-MM-DD' format.
#'
#' @return A plot of NEO data if the request is successful; otherwise, an error message.
#'
#' @examples
#' get_neo('2023-01-01', '2023-01-07')
check <- check_date(start_date, end_date)
if (check == '7_d_fail'){
print("Try another start and end date or check date format.")
return('Request failed')
}else {
response <- get_response(start_date, end_date)
}
if (response$status_code == 200){
data <- fromJSON(response$url)
plot <- get_plot(data)
print(plot)
return(plot)
}else {
return("Failed")
}
}
a <- get_neo('2018-01-07','2018-01-10')
?get_neo
??get_neo
help(get_neo)
help(get_neo)
library(httr)
library(jsonlite)
library(tibble)
library(dplyr)
library(tidyverse)
library(lubridate)
library(scales)
library(roxygen2)
get_plot <- function(data){
flat_list <- enframe(data$near_earth_objects, name = "date", value = "asteroids")
neo_data <- flat_list %>%
unnest(cols = c(asteroids)) %>%
mutate(date = as.Date(date))
flattened_close_approach_data <- enframe(neo_data$close_approach_data) %>% unnest(cols = c(value))
flattened_close_approach_data$miss_distance$kilometers <- as.numeric(flattened_close_approach_data$miss_distance$kilometers)
est_diameter_avg <- (neo_data$estimated_diameter$kilometers$estimated_diameter_max + neo_data$estimated_diameter$kilometers$estimated_diameter_min)/2
neo_data <- neo_data %>%
mutate(full_date = flattened_close_approach_data$close_approach_date_full) %>%
mutate(miss_distance_km = flattened_close_approach_data$miss_distance$kilometers) %>%
mutate(approach_velocity_km_per_h = flattened_close_approach_data$relative_velocity$kilometers_per_hour) %>%
mutate(est_diameter_avg = est_diameter_avg)
neo_data$full_date <- parse_date_time(neo_data$full_date, orders = "%Y-%b-%d %H:%M")
neo_data$full_date <- as.POSIXct(neo_data$full_date)
plot <- ggplot(neo_data, aes(x = full_date, y = miss_distance_km, size = est_diameter_avg, color = est_diameter_avg)) +
geom_point() +
ggtitle("Near Earth Objects") +
labs(x = '', y = "Miss Distance from Earth (km)", size = 'Estimated Diameter', color = '') +
theme(plot.title = element_text(hjust = 0.5)) +
scale_x_datetime(
labels = date_format("%Y-%m-%d %H:%M"),
breaks = pretty_breaks(n = 5)
) +
scale_y_continuous(
labels = scales::comma_format(scale = 1, accuracy = 1),
breaks = scales::pretty_breaks(n = 7)
) +
scale_color_viridis_c(guide = guide_colorbar(reverse = TRUE))
return(plot)
}
get_response <- function(start_date, end_date){
url <- "https://api.nasa.gov/neo/rest/v1/feed"
# start_date <- '2015-09-07'
# end_date <- '2015-09-12'
api_key <- 'gEQLIrhs9YeVTGJR9cLQ3ywn4hjsJOO59oe70KVC'
modified_url <- modify_url(url, query=list(start_date = start_date, end_date = end_date, api_key = api_key))
response <- GET(modified_url)
if (response$status_code == 200){
return(response)
}else {
print('response$headers$`x-ratelimit-remaining`')
return('Response status code not 200')
}
}
check_date <- function(start_date, end_date) {
tryCatch(
{
parsed_start_date <- as.Date(start_date)
parsed_end_date <- as.Date(end_date)
if (parsed_end_date - parsed_start_date > 7){
print('Difference between start and end date must be 7 days or less.')
return('7_d_fail')
} else {
return('PASS')
}
},
error = function(e) {
print('Date format should be in YYYY-MM-DD format.')
warning("Invalid date format. Please enter a valid date.")
}
)
}
get_neo <- function(start_date, end_date){
#' Get Near Earth Objects (NEO) Data and Plot
#'
#' This function retrieves Near Earth Objects (NEO) data for a specified date range,
#' checks the validity of the date range, and plots the data if the request is successful.
#'
#' @param start_date A character string specifying the start date in 'YYYY-MM-DD' format.
#' @param end_date A character string specifying the end date in 'YYYY-MM-DD' format.
#'
#' @return A plot of NEO data if the request is successful; otherwise, an error message.
#'
#' @examples
#' get_neo('2023-01-01', '2023-01-07')
#' @export
check <- check_date(start_date, end_date)
if (check == '7_d_fail'){
print("Try another start and end date or check date format.")
return('Request failed')
}else {
response <- get_response(start_date, end_date)
}
if (response$status_code == 200){
data <- fromJSON(response$url)
plot <- get_plot(data)
print(plot)
return(plot)
}else {
return("Failed")
}
}
a <- get_neo('2018-01-07','2018-01-10')
?get_neo
??get_neo
install.packages("testthat")
library(testthat)
source("neo_function_wrapper.R")
dirname("test_file.R")
getwd()
check_date('2023-01-01', '2023/01/07')
as.Date('2023/01/07')
as.Date('2023/001/07')
as.Date('2023/12/07')
get_response('2023-01-01', '2023-01-07')
get_response('2023-01-01', '2023-01-17')
get_neo('2023-01-01', '2023-01-10')
get_neo('2023-01-01', '2023-01-10')
get_neo('2023-01-01', '2023-01-07')
class(get_neo('2023-01-01', '2023-01-07'))
test_that("get_neo returns a ggplot object for a valid date range", {
response <- get_response('2023-01-01', '2023-01-07')
data <- fromJSON(response$url)
get_plot <- function(data) {
return(ggplot() + ggtitle("Mock Plot"))  # Stubbing, as we are focusing on testing get_neo
}
expect_is(class(get_neo('2023-01-01', '2023-01-07')), "gg")
})
test_that("get_neo returns a ggplot object for a valid date range", {
# Stubbing the get_plot function
get_plot <- function(data) {
return(ggplot2::ggplot() + ggplot2::geom_point())  # Stubbing, as we are focusing on testing get_neo
}
# Checking the class of the result
result <- get_neo('2023-01-01', '2023-01-07')
expect_true(inherits(result, 'gg'))  # Adjust the class check based on the actual class name
})
sessionInfo()
source("neo_function_wrapper.R")
a <- get_neo('2023-12-20','2023-12-27')
print(a)
=======
library(httr)
library(jsonlite)
api_key <- 'fVnQw6kAGUfwkaLWnhgmNmW7S6SxVx4E27oJgDG9'
# metadata request
get_metadata <- function(type='natural', date = NULL){
base_url <- paste("https://api.nasa.gov/EPIC/api/", type, sep = '')
# Construct the URL
url <- ifelse(is.null(date), base_url, paste0(base_url, "/date/", date))
# Make the API request
response <- GET(url, query = list(api_key = api_key))
# Check for successful response
if (http_type(response) == "application/json") {
# Parse the JSON response
data <- fromJSON(content(response, "text", encoding = "UTF-8"))
return(data)
} else {
stop("Failed to retrieve data from the EPIC API.")
}
}
# get image url
get_image_urls <- function(type='natural', date = NULL){
data <- get_metadata(type, date)
year <- substr(data$date, 1, 4)
month <- substr(data$date, 6, 7)
day <- substr(data$date, 9, 10)
image_urls <- paste('https://epic.gsfc.nasa.gov/archive', type, year, month, day, 'png', data$image, sep = '/')
image_urls <- paste(image_urls, '.png', sep = '')
image_urls
}
data <- get_metadata()
library(ggplot2)
library(ggmap)
plot_centroid <- function(type='natural', date = NULL){
data <- get_metadata(type, date)
lat <- data$centroid_coordinates$lat
lon <- data$centroid_coordinates$lon
# getting the map
map <- get_map(location = c(lon = mean(lon), lat = mean(lat)), zoom = 4,
maptype = "satellite", scale = 2)
# plotting the map with some points on it
ggmap(map) +
geom_point(aes(x = lon, y = lat, fill = "red"), size = 5, shape = 21) +
guides(fill=FALSE, alpha=FALSE, size=FALSE)
}
plot_centroid()
install.packages(c("leaflet", "sp"))
plot_centroid <- function(type='natural', date = NULL){
data <- get_metadata(type, date)
lat <- data$centroid_coordinates$lat
lon <- data$centroid_coordinates$lon
# # getting the map
# map <- get_map(location = c(lon = mean(lon), lat = mean(lat)), zoom = 4,
#                       maptype = "satellite", scale = 2)
#
# # plotting the map with some points on it
# ggmap(map) +
#   geom_point(aes(x = lon, y = lat, fill = "red"), size = 5, shape = 21) +
#   guides(fill=FALSE, alpha=FALSE, size=FALSE)
library(sp)
library(leaflet)
df <- data.frame(longitude = lon,
latitude = lat)
coordinates(df) <- ~longitude+latitude
leaflet(df) %>% addMarkers() %>% addTiles()
}
plot_centroid()
plot_centroid <- function(type='natural', date = NULL){
data <- get_metadata(type, date)
# # getting the map
# map <- get_map(location = c(lon = mean(lon), lat = mean(lat)), zoom = 4,
#                       maptype = "satellite", scale = 2)
#
# # plotting the map with some points on it
# ggmap(map) +
#   geom_point(aes(x = lon, y = lat, fill = "red"), size = 5, shape = 21) +
#   guides(fill=FALSE, alpha=FALSE, size=FALSE)
library(sp)
library(leaflet)
df <- data.frame(longitude = data$centroid_coordinates$lon,
latitude = data$centroid_coordinates$lat,
name = data$image)
coordinates(df) <- ~longitude+latitude
leaflet(df) %>% addMarkers(lable= ~htmlEscape(name)) %>% addTiles()
}
plot_centroid()
plot_centroid <- function(type='natural', date = NULL){
data <- get_metadata(type, date)
# # getting the map
# map <- get_map(location = c(lon = mean(lon), lat = mean(lat)), zoom = 4,
#                       maptype = "satellite", scale = 2)
#
# # plotting the map with some points on it
# ggmap(map) +
#   geom_point(aes(x = lon, y = lat, fill = "red"), size = 5, shape = 21) +
#   guides(fill=FALSE, alpha=FALSE, size=FALSE)
library(sp)
library(leaflet)
df <- data.frame(longitude = data$centroid_coordinates$lon,
latitude = data$centroid_coordinates$lat,
name = data$image)
#coordinates(df) <- ~longitude+latitude
leaflet(df) %>% addTiles() %>% addMarkers(~longitude, ~latitude, label = ~htmlEscape(name))
}
plot_centroid()
plot_centroid <- function(type='natural', date = NULL){
data <- get_metadata(type, date)
# # getting the map
# map <- get_map(location = c(lon = mean(lon), lat = mean(lat)), zoom = 4,
#                       maptype = "satellite", scale = 2)
#
# # plotting the map with some points on it
# ggmap(map) +
#   geom_point(aes(x = lon, y = lat, fill = "red"), size = 5, shape = 21) +
#   guides(fill=FALSE, alpha=FALSE, size=FALSE)
library(sp)
library(leaflet)
library(htmltools)
df <- data.frame(longitude = data$centroid_coordinates$lon,
latitude = data$centroid_coordinates$lat,
name = data$image)
#coordinates(df) <- ~longitude+latitude
leaflet(df) %>% addTiles() %>% addMarkers(~longitude, ~latitude, label = ~htmlEscape(name))
}
plot_centroid()
plot_centroid(date='2022-02-01')
plot_centroid(date='2022-07-01')
